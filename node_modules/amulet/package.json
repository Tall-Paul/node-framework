{
  "name": "amulet",
  "version": "0.2.7",
  "description": "As-soon-as-possible streaming async Mustache templating",
  "keywords": [
    "template",
    "mustache",
    "mu",
    "asynchronous",
    "streaming",
    "nodeps"
  ],
  "homepage": "http://github.com/chbrown/amulet",
  "bugs": {
    "url": "http://github.com/chbrown/amulet/issues",
    "email": "Christopher Brown <io@henrian.com>"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/chbrown/amulet.git"
  },
  "author": {
    "name": "Christopher Brown",
    "email": "io@henrian.com",
    "url": "http://henrian.com"
  },
  "main": "./lib/rendering.js",
  "devDependencies": {
    "optimist": "*",
    "async": "*",
    "js-yaml": "*"
  },
  "scripts": {
    "test": "./tests/test.js"
  },
  "readme": "# Amulet - Mustache templating for Node.js\n\nMustache is a simple, restricted, fast template language inspired by [ctemplate](http://code.google.com/p/google-ctemplate/). There is a great introduction to the language [here on github](http://mustache.github.com/mustache.5.html). And a nice overview of the different tags at the [ruby implementation](http://github.com/defunkt/mustache/).\n\nAmulet began as a fork of the v2 branch of [raycmorgan](https://github.com/raycmorgan)'s [Mu](https://github.com/raycmorgan/Mu). I eventually changed so much of the API that I decided to rename it.\nAmulet attempts/intends to implement all of the Mustache specification, except that it does not always honor the whitespace requirements, which, for the purposes of HTML, does not matter. (Obeying the white-space conventions is on the to-do list.)\n\n### Quickstart guide:\n\n*layout.mu*\n\n    <!DOCTYPE html>\n    <meta name=\"engine\" content=\"amulet\">\n    <div id=\"container\">\n        {{<}}\n    </div>\n\n*hello.mu*\n\n    <p>Hello world!</p>\n\n*fib.mu*\n\n    <h2>{{header}}</h2>            {{{spacer}}}\n    <!-- the spacers are there just to convince\n         your browser that it has enough content\n         to merit rendering -->\n\n    <p>One: {{one}}</p>            {{{spacer}}}\n    <p>Ten: {{ten}}</p>            {{{spacer}}}\n    <p>Hundred: {{hundred}}</p>    {{{spacer}}}\n    <p>Thousand: {{thousand}}</p>\n\n*app.js*\n\n    var amulet = require('amulet');\n    var spacer = (new Array(100)).join('&nbsp;');\n    require('http').createServer(function(req, res) {\n      if (req.url === '/fib') {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        var context = {header: 'Fibonacci sequence', spacer: spacer};\n        var renderer = amulet.render(res, ['layout.mu', 'fib.mu'], context, true);\n        var a = 0, b = 1, c = -1, i = 0;\n        (function next() {\n          for (var j = 0; j < 500000; j++) {\n            var dummy = Math.random();\n          }\n          c = a + b;\n          a = b;\n          b = c;\n          if (i === 1)\n            renderer.extendContext({one: c});\n          if (i === 10)\n            renderer.extendContext({ten: c});\n          if (i === 100)\n            renderer.extendContext({hundred: c});\n          if (i === 1000)\n            renderer.extendContext({thousand: c});\n          i++;\n          if (i < 1001)\n            process.nextTick(next);\n        })();\n      }\n      else {\n        amulet.render(res, ['layout.mu', 'hello.mu']);\n      }\n    }).listen(8080);\n\nThis example code can be found in `example/`\n\nThe main function, `amulet.render`, can be called in a few variations. The basic signature is `function(output, templates, context, asap, callback)`, but a number of the arguments are optional (`output` is the only required argument):\n\nWith callback:\n\n    amulet.render(res, ['layout.mu', 'page.mu'], context, true, function() {\n        console.log(\"Done rendering!\");\n    });\n\n`asap` defaults to false:\n\n    amulet.render(res, 'static.mu', function() { console.log(\"Done!\"); });\n\nWith single template:\n\n    var renderer = amulet.render(res, 'one.mu', {first: 'Chris'}, true);\n\n`amulet.render` always returns a Renderer object, which is useful if you want a way to add context or force it to end.\n\n*one.mu*\n\n    <h3>{{first}} {{last}}</h3>\n    <p>{{description}}</p>\n\n*app.js (snippet)*:\n\n    renderer.extendContext({last: 'Brown'});\n\nAt this point, the renderer would output up to the `<p>`\nand then pause, waiting for the description variable to be filled.\nBut if you decide you want it to skip over the missing variables,\nas any basic Mustache spec would do:\n\n    renderer.force();\n\nWhich sets `asap` to false, and immediately streams through the rest of your template.\n\n\n\n## Why Amulet when there's [Mu](https://github.com/raycmorgan/Mu)?\n\n[Mu](https://github.com/raycmorgan/Mu) is faster for certain benchmarks, because the template rendering itself is synchronous. Amulet does everything A.S.A.P. (as soon as possible), so it will start rendering your templates before any of your context variables are available, only halting when it encounters a missing variable. This functionality is optional -- if you want to render a template with one command, you still can.\n\nPHP appears so fast (while sucking so much at everything else) because it renders as soon as possible, so that the top 90% of the page gets rendered before some cpu-intensive bit gets called to render the footer. That's what Amulet does, too, basically.\n\nLike Mu, Amulet\n\n* Is very fast\n* Supports asynchronous parsing and compiling\n* Renders streamingly\n\nBeyond Mu, Amulet\n\n* Supports template hierarchies\n* Renders as soon as possible, pausing only to wait for missing variables from the controller\n* Adds a number of helpers to the Mustache specification\n\n# Additives\n\nAmulet is Mustache and then some:\n\n### Piping\n\nIf a method is in global scope, you can pipe a variable through it:\n\n    <pre>{{{doc | JSON.stringify}}}</pre>\n\nWhich would return something like\n\n    <pre>{\"_id\": \"0x1\"}</pre>\n\n### Object notation\n\nInstead of having to nest sections to dig into an object:\n\n    {{#obj}}\n        {{#prop}}\n            {{val}}\n        {{/prop}}\n    {{/obj}}\n\nYou can just dot a path. Like javascript.\n\n    {{obj.prop.val}}\n\n### DRY\n\nDon't repeat yourself; namely, don't use XML-type redundancy. A Mustache template is a directed acyclic graph (DAG), i.e. a tree, meaning that a closing node is never ambiguous. You needn't tell the Amulet parser what you're closing. It already knows.\n\n    {{#obj}}\n        {{#prop}}\n            {{val}}\n        {{/}}\n    {{/}}\n\n### Yields\n\nWhen rendering a template hierarchy, use a `<` in your master layout (the opposite of the partial symbol `>`):\n\n*layout.mu*\n\n    <!DOCTYPE html>\n    {{<}}\n\n*index.mu*\n\n    <p>Just the facts.</p>\n\nOutput of `amulet.render(response, ['layout.mu', 'index.mu'])`:\n\n    <!DOCTYPE html>\n    <p>Just the facts.</p>\n\nTo make it easier to remember what `<` does, you can also write `{{<yield}}` or even `{{<yield/>}}` to make your syntax highlighter happy. As soon as the parser sees the `<` character, it will skip to the end of the mustache tag.\n\n### Arrows\n\nTo keep better track of scope, you can name your sectioned variables with the `->` symbol:\n\n    {{#people -> person}}\n        {{person.first_name}}\n    {{/}}\n\nOtherwise, you can access the local scope nakedly or with a `_`:\n\n    {{#people}}\n        {{_.first_name}}\n        {{last_name}}\n    {{/}}\n\n\n# License\n\nMIT Licensed, 2010-2012\n\nSee <https://github.com/chbrown/amulet/blob/master/LICENSE>\n",
  "readmeFilename": "README.md",
  "_id": "amulet@0.2.7",
  "dist": {
    "shasum": "3c9100964d06de9c7029ed3a5ed980cea159307a"
  },
  "_from": "amulet@",
  "_resolved": "https://registry.npmjs.org/amulet/-/amulet-0.2.7.tgz"
}
